# -*- coding: utf-8 -*-
# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:
"""

Miscellaneous tools to support Interface functionality
......................................................

"""
from __future__ import (print_function, division, unicode_literals,
                        absolute_import)
import re
from textwrap import wrap
from builtins import object
from ... import logging, __version__
from ...utils.bunch import bunch_repr

iflogger = logging.getLogger('nipype.interface')

HELP_LINEWIDTH = 70


class NipypeInterfaceError(Exception):
    """Custom error for interfaces"""
    pass


class InterfaceRuntime(object):
    """A class to store runtime details of interfaces

    Elements can be set at initialization:

    >>> rt = InterfaceRuntime(cmdline='/bin/echo', returncode=0)
    >>> rt.returncode == 0
    True

    Unset elements are initialized to ``None``:

    >>> rt.cwd is None
    True

    And any element can be set by attribute:

    >>> rt.cwd = '/scratch/workflow'
    >>> rt.cwd
    '/scratch/workflow'

    The structure raises ``AttributeError`` if trying to accessing
    an invalid attribute:

    >>> rt.nonruntime
    Traceback (most recent call last):
        ...
    AttributeError: 'InterfaceRuntime' object has no attribute 'nonruntime'


    For Nipype to work, it is fundamental that runtime objects
    can be pickled/unpickled:

    >>> import pickle
    >>> pickleds = pickle.dumps(rt)
    >>> newrt = pickle.loads(pickleds)
    >>> newrt
    InterfaceRuntime(cmdline='/bin/echo', cwd='/scratch/workflow', returncode=0)

    Runtime objects can be compared

    >>> newrt == rt
    True

    >>> newrt != rt
    False


    >>> newrt != 'other'
    True

    >>> newrt == 'other'
    False


    """

    __slots__ = sorted([
        'cwd',
        'prevcwd',
        'returncode',
        'duration',
        'environ',
        'startTime',
        'endTime',
        'platform',
        'hostname',
        'version',
        'traceback',
        'traceback_args',
        'mem_peak_gb',
        'cpu_percent',
        'prof_dict',
        'cmdline',
        'stdout',
        'stderr',
        'merged',
        'command_path',
        'dependencies',
    ])

    def __init__(self, **inputs):
        self.__setstate__(inputs)

    def __setstate__(self, state):
        """Necessary for un-pickling"""
        for key in self.__class__.__slots__:
            setattr(self, key, state.get(key, None))

    def __getstate__(self):
        """Necessary for pickling"""
        outdict = {}
        for key in self.__class__.__slots__:
            value = getattr(self, key, None)
            if value is not None:
                outdict[key] = value
        return outdict

    def dictcopy(self):
        """
        Returns a dictionary of set attributes (backward compatibility)

        >>> rt = InterfaceRuntime()
        >>> rt.dictcopy()
        {}

        >>> rt = InterfaceRuntime(cmdline='/bin/echo', returncode=0)
        >>> rt.dictcopy()
        {'cmdline': '/bin/echo', 'returncode': 0}

        """
        return self.__getstate__()

    def items(self):
        """Provide an interface for items

        >>> rt = InterfaceRuntime()
        >>> list(rt.items())
        []

        >>> rt = InterfaceRuntime(cmdline='/bin/echo', returncode=0)
        >>> list(rt.items())
        [('cmdline', '/bin/echo'), ('returncode', 0)]


        """
        for key in self.__class__.__slots__:
            value = getattr(self, key, None)
            if value is not None:
                yield (key, value)

    def __repr__(self):
        """representation of the runtime object"""
        return bunch_repr(self, self.__class__.__name__)

    # Enable when Python 2 support is dropped
    # def __str__(self):
    #     return '%s' % self.__getstate__()

    def __eq__(self, other):
        """Overrides the default implementation"""
        if isinstance(other, InterfaceRuntime):
            return self.__getstate__() == other.__getstate__()
        return NotImplemented

    def __ne__(self, other):
        """Overrides the default implementation (Python 2)"""
        x = self.__eq__(other)
        if x is not NotImplemented:
            return not x
        return NotImplemented


class InterfaceResult(object):
    """Object that contains the results of running a particular Interface.

    Attributes
    ----------
    version : version of this Interface result object (a readonly property)
    interface : class type
        A copy of the `Interface` class that was run to generate this result.
    inputs :  a traits free representation of the inputs
    outputs : Bunch
        An `Interface` specific Bunch that contains all possible files
        that are generated by the interface.  The `outputs` are used
        as the `inputs` to another node when interfaces are used in
        the pipeline.
    runtime : Bunch

        Contains attributes that describe the runtime environment when
        the `Interface` was run.  Contains the attributes:

        * cmdline : The command line string that was executed
        * cwd : The directory the ``cmdline`` was executed in.
        * stdout : The output of running the ``cmdline``.
        * stderr : Any error messages output from running ``cmdline``.
        * returncode : The code returned from running the ``cmdline``.


    >>> rt = InterfaceRuntime(cmdline='/bin/echo', returncode=0)
    >>> result = InterfaceResult(interface='CommandLine',
    ...                          runtime=rt)
    >>> import pickle
    >>> pickleds = pickle.dumps(result)
    >>> newresult = pickle.loads(pickleds)
    >>> newresult  # doctest: +ELLIPSIS
    InterfaceResult(interface='CommandLine', runtime=\
InterfaceRuntime(cmdline='/bin/echo', returncode=0), version=...)

    """
    __slots__ = ['interface', 'runtime', 'inputs', 'outputs', 'provenance']
    version = __version__

    def __init__(self,
                 interface,
                 runtime,
                 inputs=None,
                 outputs=None,
                 provenance=None):
        self.interface = interface
        self.runtime = runtime
        self.inputs = inputs
        self.outputs = outputs
        self.provenance = provenance

    def __setstate__(self, state):
        """Necessary for un-pickling"""
        if state.get('version', None) != self.version:
            iflogger.warning(
                'Restoring an ``InterfaceResult`` from a different '
                'nipype version (current version %s, object\'s %s',
                self.version, state.get('version', '<unknown>'))
        for key in self.__class__.__slots__:
            setattr(self, key, state.get(key, None))

    def __getstate__(self):
        """Necessary for pickling"""
        outdict = {'version': self.version}
        for key in self.__class__.__slots__:
            value = getattr(self, key, None)
            if value is not None:
                outdict[key] = value
        return outdict

    def __repr__(self):
        return bunch_repr(
            self.__getstate__(), self.__class__.__name__)


def format_help(cls):
    """
    Prints help text of a Nipype interface

    >>> from nipype.interfaces.afni import GCOR
    >>> GCOR.help()  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    Wraps the executable command ``@compute_gcor``.
    <BLANKLINE>
    Computes the average correlation between every voxel
    and ever other voxel, over any give mask.
    <BLANKLINE>
    <BLANKLINE>
    For complete details, ...

    """
    from ...utils.misc import trim

    docstring = []
    cmd = getattr(cls, '_cmd', None)
    if cmd:
        docstring += ['Wraps the executable command ``%s``.' % cmd, '']

    if cls.__doc__:
        docstring += trim(cls.__doc__).split('\n') + ['']

    allhelp = '\n'.join(
        docstring +
        _inputs_help(cls) + [''] +
        _outputs_help(cls) + [''] +
        _refs_help(cls)
    )
    return allhelp.expandtabs(4)


def _inputs_help(cls):
    r"""
    Prints description for input parameters

    >>> from nipype.interfaces.afni import GCOR
    >>> _inputs_help(GCOR)  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ['Inputs::', '', '\t[Mandatory]', '\tin_file: (an existing file name)', ...

    """
    helpstr = ['Inputs::', '']
    mandatory_keys = []
    optional_items = []

    if cls.input_spec:
        inputs = cls.input_spec()
        mandatory_items = list(inputs.traits(mandatory=True).items())
        if mandatory_items:
            helpstr += ['\t[Mandatory]']
            for name, spec in sorted(mandatory_items):
                helpstr += get_trait_desc(inputs, name, spec)

        mandatory_keys = [item[0] for item in mandatory_items]
        optional_items = ['\n'.join(get_trait_desc(inputs, name, val))
                          for name, val in inputs.traits(transient=None).items()
                          if name not in mandatory_keys]
        if optional_items:
            helpstr += ['\t[Optional]'] + optional_items

    if not mandatory_keys and not optional_items:
        helpstr += ['\tNone']
    return helpstr


def _outputs_help(cls):
    r"""
    Prints description for output parameters

    >>> from nipype.interfaces.afni import GCOR
    >>> _outputs_help(GCOR)  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ['Outputs::', '', '\tout: (a float)\n\t\tglobal correlation value']

    """
    helpstr = ['Outputs::', '', '\tNone']
    if cls.output_spec:
        outputs = cls.output_spec()
        outhelpstr = [
            '\n'.join(get_trait_desc(outputs, name, spec))
            for name, spec in sorted(outputs.traits(transient=None).items())]
        if outhelpstr:
            helpstr = helpstr[:-1] + outhelpstr
    return helpstr


def _refs_help(cls):
    """Prints interface references."""
    references = getattr(cls, '_references', None)
    if not references:
        return []

    helpstr = ['References:', '-----------']
    for r in references:
        helpstr += ['{}'.format(r['entry'])]

    return helpstr


def get_trait_desc(inputs, name, spec):
    """Parses a HasTraits object into a nipype documentation string"""
    desc = spec.desc
    xor = spec.xor
    requires = spec.requires
    argstr = spec.argstr

    manhelpstr = ['\t%s' % name]

    type_info = spec.full_info(inputs, name, None)

    default = ''
    if spec.usedefault:
        default = ', nipype default value: %s' % str(
            spec.default_value()[1])
    line = "(%s%s)" % (type_info, default)

    manhelpstr = wrap(
        line,
        HELP_LINEWIDTH,
        initial_indent=manhelpstr[0] + ': ',
        subsequent_indent='\t\t  ')

    if desc:
        for line in desc.split('\n'):
            line = re.sub(r"\s+", " ", line)
            manhelpstr += wrap(
                line, HELP_LINEWIDTH,
                initial_indent='\t\t',
                subsequent_indent='\t\t')

    if argstr:
        pos = spec.position
        if pos is not None:
            manhelpstr += wrap(
                'argument: ``%s``, position: %s' % (argstr, pos),
                HELP_LINEWIDTH,
                initial_indent='\t\t',
                subsequent_indent='\t\t')
        else:
            manhelpstr += wrap(
                'argument: ``%s``' % argstr,
                HELP_LINEWIDTH,
                initial_indent='\t\t',
                subsequent_indent='\t\t')

    if xor:
        line = '%s' % ', '.join(xor)
        manhelpstr += wrap(
            line,
            HELP_LINEWIDTH,
            initial_indent='\t\tmutually_exclusive: ',
            subsequent_indent='\t\t  ')

    if requires:
        others = [field for field in requires if field != name]
        line = '%s' % ', '.join(others)
        manhelpstr += wrap(
            line,
            HELP_LINEWIDTH,
            initial_indent='\t\trequires: ',
            subsequent_indent='\t\t  ')
    return manhelpstr
